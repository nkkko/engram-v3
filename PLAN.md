Refactoring and Improvement Plan for Engram v3
=============================================

This document outlines a phased strategy for refactoring the Engram v3 codebase, enhancing maintainability, performance, and developer experience. Each phase includes objectives, key tasks, and deliverables.

Phase 0: Exploration and Setup
------------------------------
- Review existing architecture, code organization, and documentation.
- Run static analysis (gofmt, goimports, go vet, staticcheck) to establish baseline.
- Configure and verify development tooling (Go 1.21+, linters, IDE settings).

Phase 1: Code Quality and Developer Experience
----------------------------------------------
Objectives:
  - Enforce consistent style, catch common bugs early.
Tasks:
  - Integrate golangci-lint with a curated rule set.
  - Configure pre-commit hooks for formatting (gofmt, goimports) and linting.
  - Add Makefile targets or Go scripts for lint, fmt, vet.
Deliverables:
  - CI pipeline step for lint/format checks.
  - Clean baseline with zero new lint errors.

Phase 2: Architecture and Modularity
------------------------------------
Objectives:
  - Improve separation of concerns and dependency management.
Tasks:
  - Introduce a central configuration package (`internal/config`) for YAML/env parsing.
  - Replace `http.HandleFunc` with a router (e.g., chi or gorilla/mux) in `cmd/engram`.
  - Define interfaces for core components (Storage, Router, Notifier, LockManager, Search) under `internal/domain`.
  - Apply dependency injection to wire components in `main.go`.
Deliverables:
  - Modular startup sequence registering all handlers and middleware (logging, metrics).
  - Clear package boundaries and interface definitions.

Phase 3: API and Handler Refactoring
------------------------------------
Objectives:
  - Harden HTTP/gRPC API surface for validation, error handling, and context support.
Tasks:
  - Move request/response types into a single `api` package with validation methods.
  - Adopt `context.Context` in all handlers and service methods.
  - Standardize error responses, introduce error codes and mapping to HTTP status.
  - Generate OpenAPI/Swagger docs from code or proto definitions.
Deliverables:
  - Consistent API schema with autogenerated documentation.
  - Improved request validation and error reporting.

Phase 4: Storage and Persistence Abstraction
--------------------------------------------
Objectives:
  - Decouple storage implementation from business logic.
Tasks:
  - Extract Badger-specific code behind a `StorageEngine` interface.
  - Implement factory to select storage backend (Badger, in-memory, SQLite for tests).
  - Enhance tests for storage layer, add failure injection tests.
  - Optimize batching and WAL configuration parameters.
Deliverables:
  - Pluggable storage backends with clear interface.
  - Higher test coverage and performance benchmark reports.

Phase 5: Event Routing and Notifier
----------------------------------
Objectives:
  - Simplify and test the in-memory event bus and fan-out logic.
Tasks:
  - Abstract ring buffer behind an `EventRouter` interface.
  - Add unit tests for edge cases (slow subscribers, backpressure, disconnections).
  - Consider alternative implementations (channels, third-party pub/sub library).
Deliverables:
  - Well-tested, pluggable event routing with metrics for queue length and latency.

Phase 6: Lock Management Enhancements
-------------------------------------
Objectives:
  - Improve robustness of lock acquisition and deadlock prevention.
Tasks:
  - Enhance lock TTL handling and ensure crash-safe recovery via persistent state.
  - Add cancellation support using `context.Context` for long waits.
  - Expose lock metrics (held locks, waiters) via Prometheus.
Deliverables:
  - Production-ready lock manager with observability and test coverage.

Phase 7: Search Abstraction and Optimization
-------------------------------------------
Objectives:
  - Unify search API and support multiple backends (SQLite FTS5, vector engines).
Tasks:
  - Define a `SearchEngine` interface under `internal/search`.
  - Refactor existing logic to use the interface, implement FTS5 and vector stubs.
  - Benchmark query performance; optimize index updates and caching.
Deliverables:
  - Pluggable search backends with documented performance profiles.

Phase 8: Observability and Telemetry
-----------------------------------
Objectives:
  - Provide end-to-end visibility into performance and errors.
Tasks:
  - Integrate OpenTelemetry for tracing across API → storage → router → notifier.
  - Standardize structured logging with levels and fields (using zap or zerolog).
  - Expand Prometheus metrics: request latencies, error counts, queue depths.
Deliverables:
  - Dashboards and alerting rules for SLOs and error budgets.

Phase 9: Testing and Reliability
--------------------------------
Objectives:
  - Strengthen confidence through testing.
Tasks:
  - Increase unit test coverage across all packages (> 80% target).
  - Develop integration tests (spin up full engine, verify end-to-end workflows).
  - Add contract tests against OpenAPI schema or protobuf definitions.
  - Implement chaos tests (simulate WAL corruption, subscriber timeouts).
Deliverables:
  - Automated test suite in CI with coverage thresholds and reports.

Phase 10: Documentation and Onboarding
--------------------------------------
Objectives:
  - Lower barrier to entry for new contributors and users.
Tasks:
  - Consolidate docs in `/docs`, update architecture diagrams.
  - Create CONTRIBUTING.md with workflow, coding guidelines, and environment setup.
  - Provide example clients in multiple languages (Go, Python, JS).
Deliverables:
  - Up-to-date docs, quickstart guide, contribution process.